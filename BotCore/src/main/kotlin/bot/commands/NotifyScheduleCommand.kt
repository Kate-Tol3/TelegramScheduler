package org.example.bot.commands

import org.example.storage.model.EventType
import org.example.storage.service.*
import org.telegram.telegrambots.extensions.bots.commandbot.commands.BotCommand
import org.telegram.telegrambots.meta.api.methods.send.SendMessage
import org.telegram.telegrambots.meta.api.objects.Chat
import org.telegram.telegrambots.meta.api.objects.User
import org.telegram.telegrambots.meta.bots.AbsSender
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException

class NotifyScheduleCommand(
    private val eventService: EventService,
    private val templateService: TemplateService,
    private val scheduledNotificationService: ScheduledNotificationService,
    private val groupService: GroupService,
    private val userService: UserService,
    private val subscriptionService: SubscriptionService,
) : BotCommand("notify_schedule", "–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ") {

    override fun execute(sender: AbsSender, user: User, chat: Chat, arguments: Array<String>) {
        val chatId = chat.id.toString()

        if (arguments.size < 7) {
            sender.execute(SendMessage(chatId, formatHelp("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.")))
            return
        }

        val eventType = try {
            EventType.valueOf(arguments[0].uppercase())
        } catch (_: Exception) {
            sender.execute(SendMessage(chatId, formatHelp("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø —Å–æ–±—ã—Ç–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ CALL, MR –∏–ª–∏ RELEASE.")))
            return
        }

        val link = arguments[1]
        if (!link.startsWith("http")) {
            sender.execute(SendMessage(chatId, formatHelp("‚ùå –°—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http –∏–ª–∏ https.")))
            return
        }

        val startTime = arguments[2]
        if (!startTime.matches(Regex("\\d{1,2}:\\d{2}"))) {
            sender.execute(SendMessage(chatId, formatHelp("‚ùå –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —É–∫–∞–∑–∞–Ω–æ –Ω–µ–≤–µ—Ä–Ω–æ. –ü—Ä–∏–º–µ—Ä: 15:00")))
            return
        }

        val dateIndex = arguments.indexOfFirst { it.matches(Regex("\\d{2}\\.\\d{2}\\.\\d{4}")) }
        if (dateIndex == -1 || dateIndex + 1 >= arguments.size) {
            sender.execute(SendMessage(chatId, formatHelp("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–∞—Ç–∞ –∏–ª–∏ –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")))
            return
        }

        val dateStr = arguments[dateIndex]
        val timeStr = arguments[dateIndex + 1]
        val eventTime = try {
            LocalDateTime.parse("$dateStr $timeStr", DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm"))
        } catch (_: DateTimeParseException) {
            sender.execute(SendMessage(chatId, formatHelp("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –∏–ª–∏ –≤—Ä–µ–º–µ–Ω–∏: $dateStr $timeStr")))
            return
        }

        val place = arguments.slice(3 until dateIndex).joinToString(" ").ifBlank { "–ú–µ—Å—Ç–æ –Ω–µ —É–∫–∞–∑–∞–Ω–æ" }

        val tail = arguments.drop(dateIndex + 2)

        val fullTail = tail.joinToString(" ")
        val parts = fullTail.split(";")

        var description = "–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è"
        var repeatUsers = 1
        var repeatGroups = 0
        var interval = 0
        var groupName: String? = null

        if (parts.size >= 2) {
            description = parts[0].trim().ifBlank { "–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è" }

            val params = parts[1].trim().split(" ")

            if (params.size >= 3 && params[0].matches(Regex("\\d+")) &&
                params[1].matches(Regex("\\d+")) && params[2].matches(Regex("\\d+"))
            ) {
                repeatUsers = params[0].toInt()
                repeatGroups = params[1].toInt()
                interval = params[2].toInt()
                groupName = params.drop(3).joinToString(" ").ifBlank { null }
            }
        } else {
            description = tail.joinToString(" ").ifBlank { "–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è" }
        }


        val template = templateService.findByEventType(eventType)
        if (template == null) {
            sender.execute(SendMessage(chatId, "‚ö†Ô∏è –ù–µ—Ç —à–∞–±–ª–æ–Ω–∞ –¥–ª—è —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è $eventType"))
            return
        }

        val dbUser = userService.resolveUser(user)
        val group = groupName?.let { groupService.findByName(it, chatId, dbUser) }

        if (group != null) {
            val isSenderSubscribed = subscriptionService.findUsersByGroup(group)
                .any { it.telegramId == user.id }

            if (!isSenderSubscribed) {
                sender.execute(SendMessage(chatId, "‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –≥—Ä—É–ø–ø—É \"${group.name}\". –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–µ —Å–æ–∑–¥–∞–Ω–æ."))
                return
            }

            val isOwner = group.owner?.telegramId == user.id
            val isNotifier = dbUser in group.notifiers

            if (group.isPrivate && !isOwner && !isNotifier) {
                sender.execute(SendMessage(chatId, "‚ùå –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –∏–ª–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–∏ –º–æ–≥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø—É \"${group.name}\""))
                return
            }

            if (repeatUsers <= 0 && repeatGroups <= 0) {
                sender.execute(SendMessage(chatId, "‚ö†Ô∏è –£–∫–∞–∂–∏—Ç–µ –ø–æ–≤—Ç–æ—Ä—ã (–≤ –õ–° –∏–ª–∏ –≤ –≥—Ä—É–ø–ø—É), —á—Ç–æ–±—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –±—ã–ª–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ."))
                return
            }
        }

        val event = eventService.createEvent(
            type = eventType,
            payload = mapOf(
                "link" to link,
                "place" to place,
                "time" to startTime,
                "description" to description,
                "originChatId" to chatId
            )
        )

        try {
            scheduledNotificationService.create(
                template = template,
                eventTime = eventTime,
                repeatIntervalMinutes = interval,
                repeatCountUsers = repeatUsers,
                repeatCountGroups = repeatGroups,
                event = event,
                group = group,
                users = when {
                    group == null -> setOf(dbUser)
                    repeatUsers > 0 -> subscriptionService.findUsersByGroup(group).toSet()
                    else -> emptySet()
                }
            )
        } catch (e: Exception) {
            sender.execute(SendMessage(chatId, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: ${e.message}"))
            return
        }

        val formattedTime = eventTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"))
        sender.execute(SendMessage(chatId, "‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ $formattedTime"))
    }

    private fun formatHelp(reason: String): String {
        return """
            $reason

üìå –§–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã:
/notify_schedule <CALL|MR|RELEASE> <—Å—Å—ã–ª–∫–∞> <–≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞> <–º–µ—Å—Ç–æ...> <–¥–∞—Ç–∞> <–≤—Ä–µ–º—è> <–æ–ø–∏—Å–∞–Ω–∏–µ...> [–ø–æ–≤—Ç–æ—Ä—ã –≤ –õ–°] [–ø–æ–≤—Ç–æ—Ä—ã –≤ –≥—Ä—É–ø–ø—É] [–∏–Ω—Ç–µ—Ä–≤–∞–ª] [–≥—Ä—É–ø–ø–∞]

üß© –ü—Ä–∏–º–µ—Ä:
/notify_schedule CALL https://zoom.us/j/123456789 15:00 Zoom 21.07.2025 15:00 –û–±—Å—É–∂–¥–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞ 2 1 10 backend
        """.trimIndent()
    }
}
